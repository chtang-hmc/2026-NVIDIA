# Verification strategy (MTS / LABS)

Goal: The goal of verification is to ensure that our Memetic Tabu Search (MTS) implementation is **correct, deterministic when seeded, and internally consistent** before accelerating with CuPy/Numba.

## How to run the code
- Unit tests: `tests/test_mts.py`
- Pytest config: `pytest.ini`

### How to run

From the repo root:

```bash
pytest
```

If you’re running in an environment without pytest installed:

```bash
python -m pip install pytest
pytest
```

### Coverage philosophy

We prioritized tests that:
- Prove the LABS objective is implemented correctly.
- Validate the incremental-update logic (most likely to break during GPU/Numba refactors).
- Ensure reproducibility (critical for benchmarking GPU speedups later).

## What we test (and why)
The section explains approaches we used to verify the correctness of energy computation. The code can be found in `test.py()`. 

## Energy correctness(LABS objective)
- Known small-case energy matches hand calculation (e.g. all-ones length 4 has energy 14).
- Batch energy (`(k,N)`) matches single energy (`(N,)`) per-row.

## Known invariants / symmetries
The second approach we use is to employ symmetries: Energy remains constant over a (1) global shift and (2) a sequence reversal. 
- Global shift: Energy of the Ising model satisfies
  $$
  E(s)=E(-s)
  $$
  where $s=(s_1, s_2,\dots, s_i)$ is an array of spin values. The test is performed by `_flip(s: np.ndarray, j: int)`, where the function takes an array of spins $s$ and artificially flips them to $-s$. The function is used to validate single-spin flip energy changes. 

- Sequence reversal: Consider a spin $s=[s_1, s_2, \dots s_i]$. If reversing the array to $[s_i, s_{i-1}, \dots s_1]$, configurations maintain the same amount of energy. Thus, 
  $$
  E(s) = E(s[::-1])
  $$
  These invariants are easy to violate if indexing is wrong. 

Note that both global shift and sqeuence reversal are tested by `test_energy_invariants_global_flip_and_reverse`, where energies of $E(s)$, $E(-s)$ are computed and compared. The function returns an error if the equality does not hold.

- Alternating inversion: The function `_alternating_inversion(s)` applies the LABS gauge
symmetry of 
  $$
  s_i\rightarrow (-1)^i s_i
  $$
  where 0th,2nd,4th,... 2kth spins are fliiped since they correspond to odd mumber indices $i=1,3,5$.


- **Tabu-search internal math**:
  - `_delta_energy_for_flip` matches full recomputation after flipping any single bit.
  - `_apply_flip_in_place` keeps the cached autocorrelation vector consistent with recomputation.

- **Search behavior / reliability**:
  - `tabu_search()` returns a best solution that is **never worse** than the starting solution.
  - `MTS()` is **deterministic given a seed**.
  - `MTS(population0=...)` uses the provided population and returns the correct initial best when `max_iter=0`.

## 2D Arrays
The function `test_energy_single_vs_batch_consistency` verfies that energy behaves identically the same whether we give one or a batch of sequences. Consider a 2D array of `pop` defined as:
$$\text{pop} = [
  s₀ = [+1 -1, +1, +1], \\
  s₁ = [-1, -1, +1, -1],\\
  s₂ = [+1, +1, +1, -1]\dots]
$$
The function `energy(pop)` returns a lsit of energy values $E=[E_1, E_2, E_3, \dots E_i]$ where $E_i$ corresponds to the energy value of the ith spin array. The second way to compute $E_i$ is to extract the ith element from the array using `pop[i]` and then call the function `energy(pop)[i]`. Because the two spin arrays are exactly the same, they have the same energy.


## Verification for the Spin Array Input
Population generated by exercise 5 of phase 1 uses binary digits of 0 and 1. Spin values of the Ising model are $\pm 1$ only. Thus, in order to comute energy correctly, one must convert the binary array to $\pm$, which is done by `generate_bitstrings(k, N, seed)`. The verification checks the following aspects:
1. All spins array have a length greater or equal to 1. For small $N$ for testing case, we restrict $N$ under 16 to reduce computational efforts. 
2. A shape of $(k, N)$, where $k$ is the number of spin sequence and $N$ is the length of each spin array. 
3. values must be $\pm 1$
4. Deterministic when seed is fixed

The first property, a length between 1 to 16, is verified by `_all_bitstrings_pm1(N: int)`, where we input an array and verify its length.

Properties 2 to 4 are verified by the function `test_generate_bitstrings_shape_and_values()`, where we artifically generate a bistrings of shape $(k, N)=(7, 13)$ and verify if there exist a mismatch in dimension or a elements whose spin valu $s_i\notin \{-1, 1\}$ using assert().



